#!/usr/bin/env python3

# Import successive releases into a git repository, for conservatory.github.io 

# Copyright (C) 2017 by Karl Fogel
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the Affero GNU General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the Affero
# GNU General Public License for more details.
# 
# You should have received a copy of the Affero GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

__doc__ = """\
Import successive releases into a git repository,
for preservation at conservatory.github.io.

Usage:

  ./${0} [-p PREFIX_FILE] DIST-0.0.tar.gz [DIST-0.1.tar.gz [...]]

Create a git repository named DIST, and import successive releases
into it.  The arguments are the release tarballs, and they must be
presented as arguments in the right order -- this program does not yet
try to fix the ordering if you get it wrong.

The releases can have ".tar.gz" or ".tgz" extensions.  (Support for
bzip2, etc is planned, and patches are welcome of course.)

If a PREFIX_FILE is provided, prepend it to the 'README' file in the
distribution in each commit, finding the README by trying reasonable
variations such as 'README.md', 'readme.txt', etc.
"""

import getopt
import sys
import subprocess
import pathlib
import os
import re


def main():
    readme_prefix = None

    try:
        (opts, args) = getopt.getopt(sys.argv[1:], "ph?", [ "help", "usage" ])
    except getopt.GetoptError as err:
        sys.stderr.write(str(err))
        sys.stderr.write("\n")
        sys.exit(1)

    for opt, optarg in opts:
        if opt in ("-h", "-?", "--help", "--usage"):
            print(__doc__)
            sys.exit(0)
        elif opt in ("-p"):
            with open(optarg, 'r') as f:
                readme_prefix = f.read()

    if len(args) < 1:
        sys.stderr.write("ERROR: Need at least one release to work with.\n")
        sys.exit(1)

    relname_matcher = re.compile("^(.*)(-|_)([0-9.]+)(\\.|-|_)"
                         "(tar\\.gz|tgz|zip|bzip|bzip2|z|Z|)$")

    # Figure out the name of the thing.
    m = relname_matcher.match(args[0])
    if m is None:
        sys.stderr.write("ERROR: Can't figure out name from '%s'.\n" % args[0])
        sys.exit(1)
    name = m.group(1)

    # Ensure there is a local Git repository, either by making it or by
    # finding one already here (in which case we assume it's the one we
    # want to use -- i.e., that it already has earlier versions in its
    # history and that we're just adding new versions on top of those.
    if os.path.isfile(name):
        sys.stderr.write("ERROR: New git repository blocked by file at '%s'.\n"
                         % name)
        sys.exit(1)
    elif os.path.isdir(name) and not os.path.isdir(os.path.join(name, ".git")):
        sys.stderr.write("ERROR: Directory at '%s' is not a Git repository.\n"
                         % name)
        sys.exit(1)
    elif not os.path.exists(name):
        subprocess.call(['git', 'init', name,])
    else:
        print("Proceeding with '%s' as an existing Git repository." % name)

    # Let's just assume that a lexical sort will DTRT.  It probably will.
    for release in sorted(args):
        m = relname_matcher.match(release)
        if m is None:
            sys.stderr.write("ERROR: Can't parse release '%s'.\n" % args[0])
            sys.exit(1)
        print("Release number: %s" % m.group(3))
        print("Extension:      '%s'" % m.group(5))
        print("")
        # Sure hope those arguments are in the right order, and that each
        # tarball unpacks into a predictably-uniquely-named directory.
        #
        # TODO: Some day, handle more things than just gzipped tar files.
        # subprocess.call(['tar', 'zxvf', release,])
        #
        # Aha:
        # https://stackoverflow.com/questions/3949741/how-do-i-import-a-new-release-of-a-project-into-my-git-repository
        # has some good ideas about how to do this.  Despite the way
        # conversation in the comments there went, it looks like 
        # 'git add -A' is the way to go, and
        # https://stackoverflow.com/questions/572549/difference-between-git-add-a-and-git-add
        # seems to confirm this.

    # WIP: working here


if __name__ == '__main__':
    main()
